Работа с API.

Сохранение фигур.
Запрос: ```POST``` ```/figure```

Пример:

```
curl --location --request POST 'https://localhost:5001/figure' \
--header 'Content-Type: application/json' \
--data-raw '{
    "type": "circle",
    "radius": 8
}'
```

```
curl --location --request POST 'https://localhost:5001/figure' \
--header 'Content-Type: application/json' \
--data-raw '{
    "type": "triangle",
    "A": 3,
    "B": 4,
    "C": 5
}'
```

Ответ

Код: ```200```

```
{
    "id": 1
}
```

Если переданы невалидные аргументы:

```
curl --location --request POST 'https://localhost:5001/figure' \
--header 'Content-Type: application/json' \
--data-raw '{
    "type": "triangle",
    "A": -3,
    "B": 4,
    "C": 5
}'
```

Ответ

Код: ```400```

```
{
    "title": "Invalid argument supplied",
    "detail": "Length of a side of the triangle should be a positive number (Parameter 'a')"
}
```

Получение площади.

Запрос: ```GET``` ```/figure/{id}```

Пример:

```
curl --location --request GET 'https://localhost:5001/figure/3'
```

Ответ

Код: ```200```

```
{
    "area": 6.0
}
```

Если такой фигуры не существует

```curl --location --request GET 'https://localhost:5001/figure/5'```

Ответ

Код: ```404```

```
{
    "title": "Specified entity does not exist",
    "detail": "There is no figure associated with id 5"
}
```

Trade-offs.

Хранилище:
1. Схема была выбрана таким образом, чтобы добавление новых фигур не приводило к её изменению. Вместо сериализации фигуры в одно из полей таблицы можно было бы использовать классическую схему: сущность + атрибуты. Это позволило бы выиграть место в хранилище за счёт усложнения кодовой базы, сделал выбор в пользу простоты.
2. UOW. Обычно в production для организации взаимодействия с БД используется более сложный паттерн: с транзакциями, передачей uow через контекст операции, IoC. Всё это в рамках данной задачи избыточно ввиду чрезвычайно простой логики работы с БД и самой схемы БД. Поэтому в единственном репозитории я работаю с контекстом EF напрямую. Расширяемость схемы бд ограничена, выбор в пользу простоты.
3. Автоматические миграции не очень хорошее решение для production. Но для целей тестового задания это, как мне кажется, то что нужно. Выбор в пользу простоты.

API:
1. Тип фигуры. На мой взгляд было бы лучше, если бы контракт API предполагал передачу типа фигуры как части url. Это бы конечно привело к тому, что на каждый тип пришлось делать отдельный метод в контроллере. Может, это идет вразрез с требованием "расширяемости". Если мы ставим слишком большой акцент на расширяемости код получается очень сложным, слишком абстрактным и ошибкоопасным. Поэтому, если фигур не очень много, я бы делал явное описание для каждой из них. Если фигур предполагается от нескольких десятков - тогда я бы избавился от конкретных описаний по максимуму, чтобы ещё сильнее упростить расширение. Я попытался удержаться где-то в середине. Четко следовал установленному в задаче контракту, но каждую фигуру описал в модели отдельно. Говоря о url, я бы для описания ресурсов использовал множественное число.
2. Обработка ошибок (преобразование исключения в специальный объект) вынесена в мидлвару. Это сделано чтобы избавить контроллер от этой обязанности. Структура проекта стала немного сложнее, но код контроллера стал проще.
3. Преобразование входного json в dto фигуры выделено в отдельный конвертер. Кажется, это самый простой способ прийти к такому публичному контракту, который не будет требовать изменений при добавлении новой фигуры. Альтернатива - передавать некие словари параметров и разбирать их отдельно. Думаю, такой код был бы ещё сложнее в итоге.

Модель: ядро бизнес-логики попытался выразить в DDD стиле. На практике богатую модель использую нечасто, но иногда она просится.

Тесты: xUnit + Shouldly + NSubstitute. Эти инструменты мне нравятся за естественность и лаконичность.

IoC: использовал Autofac т.к. он более знакомый, а требования к контейнеру здесь крайне низкие, подошел бы любой. Не было смысла заморачиваться с другим инструментом. Но можно было бы подумать на счет SimpleInjector, например.
