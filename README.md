Работа с API.

Сохранение фигур.
Запрос: POST /figure
Пример:

curl --location --request POST 'https://localhost:5001/figure' \
--header 'Content-Type: application/json' \
--data-raw '{
    "type": "circle",
    "radius": 8
}'

curl --location --request POST 'https://localhost:5001/figure' \
--header 'Content-Type: application/json' \
--data-raw '{
    "type": "triangle",
    "A": 3,
    "B": 4,
    "C": 5
}'

Ответ
Код: 200
{
    "id": 1
}

Если переданы невалидные аргументы:
curl --location --request POST 'https://localhost:5001/figure' \
--header 'Content-Type: application/json' \
--data-raw '{
    "type": "triangle",
    "A": -3,
    "B": 4,
    "C": 5
}'

Ответ
Код: 400
{
    "title": "Invalid argument supplied",
    "detail": "Length of a side of the triangle should be a positive number (Parameter 'a')"
}

Получение площади.
Запрос: GET /figure/{id}
Пример:
curl --location --request GET 'https://localhost:5001/figure/3'

Ответ
Код: 200
{
    "area": 6.0
}

Если такой фигуры не существует
curl --location --request GET 'https://localhost:5001/figure/5'
Ответ
Код: 404
{
    "title": "Specified entity does not exist",
    "detail": "There is no figure associated with id 5"
}

Trade-offs.

Хранилище:
1. Схема была выбрана таким образом, чтобы добавление новых фигур не приводило к её изменению.
Вместо сериализации фигуры в одно из полей таблицы можно было бы использовать классическую схему: сущность + атрибуты.
Это позволило бы выиграть место в хранилище за счёт усложнения кодовой базы, сделал выбор в пользу простоты.
2. UOW. Обычно в production для организации взаимодействия с БД используется более сложный паттерн: с транзакциями, передачей uow через контекст операции, IoC.
Всё это в рамках данной задачи избыточно ввиду чрезвычайно простой логики работы с БД и самой схемы БД. Поэтому в единственном репозитории я работаю с контекстом EF напрямую.
Расширяемость схемы бд ограничена, выбор в пользу простоты.
3. Автоматические миграции не очень хорошее решение для production. Но для целей тестового задания это, как мне кажется, то что нужно. Выбор в пользу простоты.

API:
1. Тип фигуры. На мой взгляд было бы лучше, если бы контракт API предполагал передачу типа фигуры как части url.
Это бы конечно привело к тому, что на каждый тип пришлось делать отдельный метод в контроллере. Может, это идет вразрез с требованием "расширяемости".
Если мы ставим слишком большой акцент на расширяемости код получается очень сложным, слишком абстрактным и ошибкоопасным.
Поэтому, если фигур не очень много, я бы делал явное описание для каждой из них.
Если фигур предполагается от нескольких десятков - тогда я бы избавился от конкретных описаний по максимуму, чтобы ещё сильнее упростить расширение.
Я попытался удержаться где-то в середине. Четко следовал установленному в задаче контракту, но каждую фигуру описал в модели отдельно.
Говоря о url, я бы для описания ресурсов использовал множественное число.
2. Обработка ошибок (преобразование исключения в специальный объект) вынесена в мидлвару. Это сделано чтобы избавить контроллер от этой обязанности.
Структура проекта стала немного сложнее, но код контроллера стал проще.
3. Преобразование входного json в dto фигуры выделено в отдельный конвертер. Кажется, это самый простой способ прийти к такому публичному контракту,
который не будет требовать изменений при добавлении новой фигуры. Альтернатива - передавать некие словари параметров и разбирать их отдельно.
Думаю, такой код был бы ещё сложнее в итоге.

Модель:
Ядро бизнес-логики попытался выразить в DDD стиле. На практике богатую модель использую нечасто, но иногда она просится.

Тесты:
xUnit + Shouldly + NSubstitute. Эти инструменты мне нравятся за естественность и лаконичность.

IoC:
Использовал Autofac т.к. он более знакомый, а требования к контейнеру здесь крайне низкие, подошел бы любой.
Не было смысла заморачиваться с другим инструментом. Но можно было бы подумать на счет SimpleInjector, например.